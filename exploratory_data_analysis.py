# -*- coding: utf-8 -*-
"""Exploratory_Data_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JzK_m-tKBPGlHtRGtQgqSM9CmmI5bjYA
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load the dataset
def load_data(file_path):
    try:
        df = pd.read_csv(file_path)
        df['Date'] = pd.to_datetime(df['Date'], format='%m/%d/%Y')
        logger.info("Data loaded successfully. Shape: %s", df.shape)
        return df
    except Exception as e:
        logger.error("Error loading data: %s", e)
        raise

# Summary statistics
def compute_summary_statistics(df):
    logger.info("Computing summary statistics...")
    numerical_cols = ['USD_Balance', 'BTC_Price', 'ETH_Price', 'Portfolio_Value_USD',
                     'Total_PnL', 'Win_Count', 'Loss_Count', 'Avg_R_Factor',
                     'News_Sentiment_Avg', 'Social_Sentiment_Avg', 'Index']
    summary = df[numerical_cols].describe()
    logger.info("Summary statistics:\n%s", summary.to_string())
    return summary

# Distribution plots
def plot_distributions(df):
    logger.info("Generating distribution plots...")
    numerical_cols = ['USD_Balance', 'Portfolio_Value_USD', 'Total_PnL',
                     'News_Sentiment_Avg', 'Social_Sentiment_Avg', 'Index']
    plt.figure(figsize=(15, 10))
    for i, col in enumerate(numerical_cols, 1):
        plt.subplot(3, 2, i)
        sns.histplot(df[col], kde=True)
        plt.title(f'Distribution of {col}')
        plt.xlabel(col)
        plt.ylabel('Count')
    plt.tight_layout()
    plt.show()

# Time series plots
def plot_time_series(df):
    logger.info("Generating time series plots...")
    plt.figure(figsize=(15, 12))

    # Portfolio Value and USD Balance
    plt.subplot(3, 1, 1)
    plt.plot(df['Date'], df['Portfolio_Value_USD'], label='Portfolio Value (USD)', marker='o')
    plt.plot(df['Date'], df['USD_Balance'], label='USD Balance', marker='s')
    plt.title('Portfolio Value and USD Balance Over Time')
    plt.xlabel('Date')
    plt.ylabel('USD')
    plt.legend()
    plt.grid(True)

    # BTC and ETH Prices
    plt.subplot(3, 1, 2)
    plt.plot(df['Date'], df['BTC_Price'], label='BTC Price', marker='o')
    plt.plot(df['Date'], df['ETH_Price'], label='ETH Price', marker='s')
    plt.title('BTC and ETH Prices Over Time')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid(True)

    # Sentiment Scores
    plt.subplot(3, 1, 3)
    plt.plot(df['Date'], df['News_Sentiment_Avg'], label='News Sentiment', marker='o')
    plt.plot(df['Date'], df['Social_Sentiment_Avg'], label='Social Sentiment', marker='s')
    plt.title('News and Social Sentiment Over Time')
    plt.xlabel('Date')
    plt.ylabel('Sentiment Score')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    plt.show()

# Correlation matrix
def plot_correlation_matrix(df):
    logger.info("Generating correlation matrix...")
    numerical_cols = ['USD_Balance', 'BTC_Price', 'ETH_Price', 'Portfolio_Value_USD',
                     'Total_PnL', 'Win_Count', 'Loss_Count', 'Avg_R_Factor',
                     'News_Sentiment_Avg', 'Social_Sentiment_Avg', 'Index']
    corr_matrix = df[numerical_cols].corr()
    plt.figure(figsize=(10, 8))
    sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f')
    plt.title('Correlation Matrix')
    plt.show()
    return corr_matrix

# Categorical analysis
def analyze_sentiment_categories(df):
    logger.info("Analyzing sentiment categories...")
    plt.figure(figsize=(8, 5))
    sns.countplot(data=df, x='Sentiment')
    plt.title('Distribution of Market Sentiment')
    plt.xlabel('Sentiment')
    plt.ylabel('Count')
    plt.show()

    # Sentiment vs. Total_PnL
    plt.figure(figsize=(8, 5))
    sns.boxplot(data=df, x='Sentiment', y='Total_PnL')
    plt.title('Total PnL by Market Sentiment')
    plt.xlabel('Sentiment')
    plt.ylabel('Total PnL (USD)')
    plt.show()

# Outlier detection
def detect_outliers(df):
    logger.info("Detecting outliers...")
    numerical_cols = ['USD_Balance', 'Portfolio_Value_USD', 'Total_PnL',
                     'News_Sentiment_Avg', 'Social_Sentiment_Avg', 'Index']
    outliers = {}
    for col in numerical_cols:
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        outliers[col] = df[(df[col] < lower_bound) | (df[col] > upper_bound)][['Date', col]]
        if not outliers[col].empty:
            logger.info("Outliers in %s:\n%s", col, outliers[col].to_string())
    return outliers

# Main EDA function
def perform_eda(file_path):
    df = load_data(file_path)
    summary = compute_summary_statistics(df)
    plot_distributions(df)
    plot_time_series(df)
    corr_matrix = plot_correlation_matrix(df)
    analyze_sentiment_categories(df)
    outliers = detect_outliers(df)
    return df, summary, corr_matrix, outliers

if __name__ == "__main__":
    file_path = "processed_data.csv"  # Update with actual path
    df, summary, corr_matrix, outliers = perform_eda(file_path)
    logger.info("EDA completed.")